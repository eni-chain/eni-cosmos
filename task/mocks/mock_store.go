// Code generated by MockGen. DO NOT EDIT.
// Source: store/types/store.go

// Package mocks is a generated GoMock package.
package mocks

import (
	io0 "io"
	reflect "reflect"

	metrics "cosmossdk.io/store/metrics"
	types "cosmossdk.io/store/pruning/types"
	types0 "cosmossdk.io/store/snapshots/types"
	types1 "cosmossdk.io/store/types"
	db "github.com/cosmos/cosmos-db"
	io "github.com/cosmos/gogoproto/io"
	gomock "github.com/golang/mock/gomock"
)

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method.
func (m *MockStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockStore)(nil).CacheWrapWithTrace), w, tc)
}

// GetStoreType mocks base method.
func (m *MockStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockStore)(nil).GetStoreType))
}

// MockCommitter is a mock of Committer interface.
type MockCommitter struct {
	ctrl     *gomock.Controller
	recorder *MockCommitterMockRecorder
}

// MockCommitterMockRecorder is the mock recorder for MockCommitter.
type MockCommitterMockRecorder struct {
	mock *MockCommitter
}

// NewMockCommitter creates a new mock instance.
func NewMockCommitter(ctrl *gomock.Controller) *MockCommitter {
	mock := &MockCommitter{ctrl: ctrl}
	mock.recorder = &MockCommitterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommitter) EXPECT() *MockCommitterMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockCommitter) Commit() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockCommitterMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitter)(nil).Commit))
}

// GetPruning mocks base method.
func (m *MockCommitter) GetPruning() types.PruningOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPruning")
	ret0, _ := ret[0].(types.PruningOptions)
	return ret0
}

// GetPruning indicates an expected call of GetPruning.
func (mr *MockCommitterMockRecorder) GetPruning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPruning", reflect.TypeOf((*MockCommitter)(nil).GetPruning))
}

// LastCommitID mocks base method.
func (m *MockCommitter) LastCommitID() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID.
func (mr *MockCommitterMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitter)(nil).LastCommitID))
}

// SetPruning mocks base method.
func (m *MockCommitter) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning.
func (mr *MockCommitterMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitter)(nil).SetPruning), arg0)
}

// WorkingHash mocks base method.
func (m *MockCommitter) WorkingHash() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorkingHash")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// WorkingHash indicates an expected call of WorkingHash.
func (mr *MockCommitterMockRecorder) WorkingHash() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorkingHash", reflect.TypeOf((*MockCommitter)(nil).WorkingHash))
}

// MockCommitStore is a mock of CommitStore interface.
type MockCommitStore struct {
	ctrl     *gomock.Controller
	recorder *MockCommitStoreMockRecorder
}

// MockCommitStoreMockRecorder is the mock recorder for MockCommitStore.
type MockCommitStoreMockRecorder struct {
	mock *MockCommitStore
}

// NewMockCommitStore creates a new mock instance.
func NewMockCommitStore(ctrl *gomock.Controller) *MockCommitStore {
	mock := &MockCommitStore{ctrl: ctrl}
	mock.recorder = &MockCommitStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommitStore) EXPECT() *MockCommitStoreMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method.
func (m *MockCommitStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockCommitStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCommitStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockCommitStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockCommitStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCommitStore)(nil).CacheWrapWithTrace), w, tc)
}

// Commit mocks base method.
func (m *MockCommitStore) Commit() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockCommitStoreMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitStore)(nil).Commit))
}

// GetPruning mocks base method.
func (m *MockCommitStore) GetPruning() types.PruningOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPruning")
	ret0, _ := ret[0].(types.PruningOptions)
	return ret0
}

// GetPruning indicates an expected call of GetPruning.
func (mr *MockCommitStoreMockRecorder) GetPruning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPruning", reflect.TypeOf((*MockCommitStore)(nil).GetPruning))
}

// GetStoreType mocks base method.
func (m *MockCommitStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockCommitStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCommitStore)(nil).GetStoreType))
}

// LastCommitID mocks base method.
func (m *MockCommitStore) LastCommitID() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID.
func (mr *MockCommitStoreMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitStore)(nil).LastCommitID))
}

// SetPruning mocks base method.
func (m *MockCommitStore) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning.
func (mr *MockCommitStoreMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitStore)(nil).SetPruning), arg0)
}

// WorkingHash mocks base method.
func (m *MockCommitStore) WorkingHash() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorkingHash")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// WorkingHash indicates an expected call of WorkingHash.
func (mr *MockCommitStoreMockRecorder) WorkingHash() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorkingHash", reflect.TypeOf((*MockCommitStore)(nil).WorkingHash))
}

// MockQueryable is a mock of Queryable interface.
type MockQueryable struct {
	ctrl     *gomock.Controller
	recorder *MockQueryableMockRecorder
}

// MockQueryableMockRecorder is the mock recorder for MockQueryable.
type MockQueryableMockRecorder struct {
	mock *MockQueryable
}

// NewMockQueryable creates a new mock instance.
func NewMockQueryable(ctrl *gomock.Controller) *MockQueryable {
	mock := &MockQueryable{ctrl: ctrl}
	mock.recorder = &MockQueryableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryable) EXPECT() *MockQueryableMockRecorder {
	return m.recorder
}

// Query mocks base method.
func (m *MockQueryable) Query(arg0 *types1.RequestQuery) (*types1.ResponseQuery, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", arg0)
	ret0, _ := ret[0].(*types1.ResponseQuery)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockQueryableMockRecorder) Query(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockQueryable)(nil).Query), arg0)
}

// MockMultiStore is a mock of MultiStore interface.
type MockMultiStore struct {
	ctrl     *gomock.Controller
	recorder *MockMultiStoreMockRecorder
}

// MockMultiStoreMockRecorder is the mock recorder for MockMultiStore.
type MockMultiStoreMockRecorder struct {
	mock *MockMultiStore
}

// NewMockMultiStore creates a new mock instance.
func NewMockMultiStore(ctrl *gomock.Controller) *MockMultiStore {
	mock := &MockMultiStore{ctrl: ctrl}
	mock.recorder = &MockMultiStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMultiStore) EXPECT() *MockMultiStoreMockRecorder {
	return m.recorder
}

// CacheMultiStore mocks base method.
func (m *MockMultiStore) CacheMultiStore() types1.CacheMultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStore")
	ret0, _ := ret[0].(types1.CacheMultiStore)
	return ret0
}

// CacheMultiStore indicates an expected call of CacheMultiStore.
func (mr *MockMultiStoreMockRecorder) CacheMultiStore() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStore", reflect.TypeOf((*MockMultiStore)(nil).CacheMultiStore))
}

// CacheMultiStoreWithVersion mocks base method.
func (m *MockMultiStore) CacheMultiStoreWithVersion(version int64) (types1.CacheMultiStore, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStoreWithVersion", version)
	ret0, _ := ret[0].(types1.CacheMultiStore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CacheMultiStoreWithVersion indicates an expected call of CacheMultiStoreWithVersion.
func (mr *MockMultiStoreMockRecorder) CacheMultiStoreWithVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStoreWithVersion", reflect.TypeOf((*MockMultiStore)(nil).CacheMultiStoreWithVersion), version)
}

// CacheWrap mocks base method.
func (m *MockMultiStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockMultiStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockMultiStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockMultiStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockMultiStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockMultiStore)(nil).CacheWrapWithTrace), w, tc)
}

// GetKVStore mocks base method.
func (m *MockMultiStore) GetKVStore(arg0 types1.StoreKey) types1.KVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetKVStore", arg0)
	ret0, _ := ret[0].(types1.KVStore)
	return ret0
}

// GetKVStore indicates an expected call of GetKVStore.
func (mr *MockMultiStoreMockRecorder) GetKVStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetKVStore", reflect.TypeOf((*MockMultiStore)(nil).GetKVStore), arg0)
}

// GetStore mocks base method.
func (m *MockMultiStore) GetStore(arg0 types1.StoreKey) types1.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStore", arg0)
	ret0, _ := ret[0].(types1.Store)
	return ret0
}

// GetStore indicates an expected call of GetStore.
func (mr *MockMultiStoreMockRecorder) GetStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStore", reflect.TypeOf((*MockMultiStore)(nil).GetStore), arg0)
}

// GetStoreType mocks base method.
func (m *MockMultiStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockMultiStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockMultiStore)(nil).GetStoreType))
}

// LatestVersion mocks base method.
func (m *MockMultiStore) LatestVersion() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestVersion")
	ret0, _ := ret[0].(int64)
	return ret0
}

// LatestVersion indicates an expected call of LatestVersion.
func (mr *MockMultiStoreMockRecorder) LatestVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestVersion", reflect.TypeOf((*MockMultiStore)(nil).LatestVersion))
}

// SetKVStores mocks base method.
func (m *MockMultiStore) SetKVStores(handler func(types1.StoreKey, types1.KVStore) types1.CacheWrap) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetKVStores", handler)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetKVStores indicates an expected call of SetKVStores.
func (mr *MockMultiStoreMockRecorder) SetKVStores(handler interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetKVStores", reflect.TypeOf((*MockMultiStore)(nil).SetKVStores), handler)
}

// SetTracer mocks base method.
func (m *MockMultiStore) SetTracer(w io0.Writer) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracer", w)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetTracer indicates an expected call of SetTracer.
func (mr *MockMultiStoreMockRecorder) SetTracer(w interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracer", reflect.TypeOf((*MockMultiStore)(nil).SetTracer), w)
}

// SetTracingContext mocks base method.
func (m *MockMultiStore) SetTracingContext(arg0 types1.TraceContext) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracingContext", arg0)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetTracingContext indicates an expected call of SetTracingContext.
func (mr *MockMultiStoreMockRecorder) SetTracingContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracingContext", reflect.TypeOf((*MockMultiStore)(nil).SetTracingContext), arg0)
}

// StoreKeys mocks base method.
func (m *MockMultiStore) StoreKeys() []types1.StoreKey {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreKeys")
	ret0, _ := ret[0].([]types1.StoreKey)
	return ret0
}

// StoreKeys indicates an expected call of StoreKeys.
func (mr *MockMultiStoreMockRecorder) StoreKeys() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreKeys", reflect.TypeOf((*MockMultiStore)(nil).StoreKeys))
}

// TracingEnabled mocks base method.
func (m *MockMultiStore) TracingEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracingEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// TracingEnabled indicates an expected call of TracingEnabled.
func (mr *MockMultiStoreMockRecorder) TracingEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracingEnabled", reflect.TypeOf((*MockMultiStore)(nil).TracingEnabled))
}

// MockCacheMultiStore is a mock of CacheMultiStore interface.
type MockCacheMultiStore struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMultiStoreMockRecorder
}

// MockCacheMultiStoreMockRecorder is the mock recorder for MockCacheMultiStore.
type MockCacheMultiStoreMockRecorder struct {
	mock *MockCacheMultiStore
}

// NewMockCacheMultiStore creates a new mock instance.
func NewMockCacheMultiStore(ctrl *gomock.Controller) *MockCacheMultiStore {
	mock := &MockCacheMultiStore{ctrl: ctrl}
	mock.recorder = &MockCacheMultiStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheMultiStore) EXPECT() *MockCacheMultiStoreMockRecorder {
	return m.recorder
}

// CacheMultiStore mocks base method.
func (m *MockCacheMultiStore) CacheMultiStore() types1.CacheMultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStore")
	ret0, _ := ret[0].(types1.CacheMultiStore)
	return ret0
}

// CacheMultiStore indicates an expected call of CacheMultiStore.
func (mr *MockCacheMultiStoreMockRecorder) CacheMultiStore() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStore", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheMultiStore))
}

// CacheMultiStoreWithVersion mocks base method.
func (m *MockCacheMultiStore) CacheMultiStoreWithVersion(version int64) (types1.CacheMultiStore, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStoreWithVersion", version)
	ret0, _ := ret[0].(types1.CacheMultiStore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CacheMultiStoreWithVersion indicates an expected call of CacheMultiStoreWithVersion.
func (mr *MockCacheMultiStoreMockRecorder) CacheMultiStoreWithVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStoreWithVersion", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheMultiStoreWithVersion), version)
}

// CacheWrap mocks base method.
func (m *MockCacheMultiStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockCacheMultiStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockCacheMultiStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockCacheMultiStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheWrapWithTrace), w, tc)
}

// GetKVStore mocks base method.
func (m *MockCacheMultiStore) GetKVStore(arg0 types1.StoreKey) types1.KVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetKVStore", arg0)
	ret0, _ := ret[0].(types1.KVStore)
	return ret0
}

// GetKVStore indicates an expected call of GetKVStore.
func (mr *MockCacheMultiStoreMockRecorder) GetKVStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetKVStore", reflect.TypeOf((*MockCacheMultiStore)(nil).GetKVStore), arg0)
}

// GetStore mocks base method.
func (m *MockCacheMultiStore) GetStore(arg0 types1.StoreKey) types1.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStore", arg0)
	ret0, _ := ret[0].(types1.Store)
	return ret0
}

// GetStore indicates an expected call of GetStore.
func (mr *MockCacheMultiStoreMockRecorder) GetStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStore", reflect.TypeOf((*MockCacheMultiStore)(nil).GetStore), arg0)
}

// GetStoreType mocks base method.
func (m *MockCacheMultiStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockCacheMultiStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCacheMultiStore)(nil).GetStoreType))
}

// LatestVersion mocks base method.
func (m *MockCacheMultiStore) LatestVersion() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestVersion")
	ret0, _ := ret[0].(int64)
	return ret0
}

// LatestVersion indicates an expected call of LatestVersion.
func (mr *MockCacheMultiStoreMockRecorder) LatestVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestVersion", reflect.TypeOf((*MockCacheMultiStore)(nil).LatestVersion))
}

// SetKVStores mocks base method.
func (m *MockCacheMultiStore) SetKVStores(handler func(types1.StoreKey, types1.KVStore) types1.CacheWrap) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetKVStores", handler)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetKVStores indicates an expected call of SetKVStores.
func (mr *MockCacheMultiStoreMockRecorder) SetKVStores(handler interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetKVStores", reflect.TypeOf((*MockCacheMultiStore)(nil).SetKVStores), handler)
}

// SetTracer mocks base method.
func (m *MockCacheMultiStore) SetTracer(w io0.Writer) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracer", w)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetTracer indicates an expected call of SetTracer.
func (mr *MockCacheMultiStoreMockRecorder) SetTracer(w interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracer", reflect.TypeOf((*MockCacheMultiStore)(nil).SetTracer), w)
}

// SetTracingContext mocks base method.
func (m *MockCacheMultiStore) SetTracingContext(arg0 types1.TraceContext) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracingContext", arg0)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetTracingContext indicates an expected call of SetTracingContext.
func (mr *MockCacheMultiStoreMockRecorder) SetTracingContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracingContext", reflect.TypeOf((*MockCacheMultiStore)(nil).SetTracingContext), arg0)
}

// StoreKeys mocks base method.
func (m *MockCacheMultiStore) StoreKeys() []types1.StoreKey {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreKeys")
	ret0, _ := ret[0].([]types1.StoreKey)
	return ret0
}

// StoreKeys indicates an expected call of StoreKeys.
func (mr *MockCacheMultiStoreMockRecorder) StoreKeys() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreKeys", reflect.TypeOf((*MockCacheMultiStore)(nil).StoreKeys))
}

// TracingEnabled mocks base method.
func (m *MockCacheMultiStore) TracingEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracingEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// TracingEnabled indicates an expected call of TracingEnabled.
func (mr *MockCacheMultiStoreMockRecorder) TracingEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracingEnabled", reflect.TypeOf((*MockCacheMultiStore)(nil).TracingEnabled))
}

// Write mocks base method.
func (m *MockCacheMultiStore) Write() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Write")
}

// Write indicates an expected call of Write.
func (mr *MockCacheMultiStoreMockRecorder) Write() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheMultiStore)(nil).Write))
}

// MockCommitMultiStore is a mock of CommitMultiStore interface.
type MockCommitMultiStore struct {
	ctrl     *gomock.Controller
	recorder *MockCommitMultiStoreMockRecorder
}

// MockCommitMultiStoreMockRecorder is the mock recorder for MockCommitMultiStore.
type MockCommitMultiStoreMockRecorder struct {
	mock *MockCommitMultiStore
}

// NewMockCommitMultiStore creates a new mock instance.
func NewMockCommitMultiStore(ctrl *gomock.Controller) *MockCommitMultiStore {
	mock := &MockCommitMultiStore{ctrl: ctrl}
	mock.recorder = &MockCommitMultiStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommitMultiStore) EXPECT() *MockCommitMultiStoreMockRecorder {
	return m.recorder
}

// AddListeners mocks base method.
func (m *MockCommitMultiStore) AddListeners(keys []types1.StoreKey) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddListeners", keys)
}

// AddListeners indicates an expected call of AddListeners.
func (mr *MockCommitMultiStoreMockRecorder) AddListeners(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddListeners", reflect.TypeOf((*MockCommitMultiStore)(nil).AddListeners), keys)
}

// CacheMultiStore mocks base method.
func (m *MockCommitMultiStore) CacheMultiStore() types1.CacheMultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStore")
	ret0, _ := ret[0].(types1.CacheMultiStore)
	return ret0
}

// CacheMultiStore indicates an expected call of CacheMultiStore.
func (mr *MockCommitMultiStoreMockRecorder) CacheMultiStore() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStore", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheMultiStore))
}

// CacheMultiStoreWithVersion mocks base method.
func (m *MockCommitMultiStore) CacheMultiStoreWithVersion(version int64) (types1.CacheMultiStore, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStoreWithVersion", version)
	ret0, _ := ret[0].(types1.CacheMultiStore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CacheMultiStoreWithVersion indicates an expected call of CacheMultiStoreWithVersion.
func (mr *MockCommitMultiStoreMockRecorder) CacheMultiStoreWithVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStoreWithVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheMultiStoreWithVersion), version)
}

// CacheWrap mocks base method.
func (m *MockCommitMultiStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockCommitMultiStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockCommitMultiStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockCommitMultiStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheWrapWithTrace), w, tc)
}

// Commit mocks base method.
func (m *MockCommitMultiStore) Commit() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockCommitMultiStoreMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitMultiStore)(nil).Commit))
}

// GetCommitKVStore mocks base method.
func (m *MockCommitMultiStore) GetCommitKVStore(key types1.StoreKey) types1.CommitKVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitKVStore", key)
	ret0, _ := ret[0].(types1.CommitKVStore)
	return ret0
}

// GetCommitKVStore indicates an expected call of GetCommitKVStore.
func (mr *MockCommitMultiStoreMockRecorder) GetCommitKVStore(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitKVStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetCommitKVStore), key)
}

// GetCommitStore mocks base method.
func (m *MockCommitMultiStore) GetCommitStore(key types1.StoreKey) types1.CommitStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitStore", key)
	ret0, _ := ret[0].(types1.CommitStore)
	return ret0
}

// GetCommitStore indicates an expected call of GetCommitStore.
func (mr *MockCommitMultiStoreMockRecorder) GetCommitStore(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetCommitStore), key)
}

// GetKVStore mocks base method.
func (m *MockCommitMultiStore) GetKVStore(arg0 types1.StoreKey) types1.KVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetKVStore", arg0)
	ret0, _ := ret[0].(types1.KVStore)
	return ret0
}

// GetKVStore indicates an expected call of GetKVStore.
func (mr *MockCommitMultiStoreMockRecorder) GetKVStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetKVStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetKVStore), arg0)
}

// GetPruning mocks base method.
func (m *MockCommitMultiStore) GetPruning() types.PruningOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPruning")
	ret0, _ := ret[0].(types.PruningOptions)
	return ret0
}

// GetPruning indicates an expected call of GetPruning.
func (mr *MockCommitMultiStoreMockRecorder) GetPruning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPruning", reflect.TypeOf((*MockCommitMultiStore)(nil).GetPruning))
}

// GetStore mocks base method.
func (m *MockCommitMultiStore) GetStore(arg0 types1.StoreKey) types1.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStore", arg0)
	ret0, _ := ret[0].(types1.Store)
	return ret0
}

// GetStore indicates an expected call of GetStore.
func (mr *MockCommitMultiStoreMockRecorder) GetStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetStore), arg0)
}

// GetStoreType mocks base method.
func (m *MockCommitMultiStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockCommitMultiStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCommitMultiStore)(nil).GetStoreType))
}

// LastCommitID mocks base method.
func (m *MockCommitMultiStore) LastCommitID() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID.
func (mr *MockCommitMultiStoreMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitMultiStore)(nil).LastCommitID))
}

// LatestVersion mocks base method.
func (m *MockCommitMultiStore) LatestVersion() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestVersion")
	ret0, _ := ret[0].(int64)
	return ret0
}

// LatestVersion indicates an expected call of LatestVersion.
func (mr *MockCommitMultiStoreMockRecorder) LatestVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).LatestVersion))
}

// ListeningEnabled mocks base method.
func (m *MockCommitMultiStore) ListeningEnabled(key types1.StoreKey) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListeningEnabled", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ListeningEnabled indicates an expected call of ListeningEnabled.
func (mr *MockCommitMultiStoreMockRecorder) ListeningEnabled(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListeningEnabled", reflect.TypeOf((*MockCommitMultiStore)(nil).ListeningEnabled), key)
}

// LoadLatestVersion mocks base method.
func (m *MockCommitMultiStore) LoadLatestVersion() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadLatestVersion")
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadLatestVersion indicates an expected call of LoadLatestVersion.
func (mr *MockCommitMultiStoreMockRecorder) LoadLatestVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadLatestVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).LoadLatestVersion))
}

// LoadLatestVersionAndUpgrade mocks base method.
func (m *MockCommitMultiStore) LoadLatestVersionAndUpgrade(upgrades *types1.StoreUpgrades) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadLatestVersionAndUpgrade", upgrades)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadLatestVersionAndUpgrade indicates an expected call of LoadLatestVersionAndUpgrade.
func (mr *MockCommitMultiStoreMockRecorder) LoadLatestVersionAndUpgrade(upgrades interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadLatestVersionAndUpgrade", reflect.TypeOf((*MockCommitMultiStore)(nil).LoadLatestVersionAndUpgrade), upgrades)
}

// LoadVersion mocks base method.
func (m *MockCommitMultiStore) LoadVersion(ver int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadVersion", ver)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadVersion indicates an expected call of LoadVersion.
func (mr *MockCommitMultiStoreMockRecorder) LoadVersion(ver interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).LoadVersion), ver)
}

// LoadVersionAndUpgrade mocks base method.
func (m *MockCommitMultiStore) LoadVersionAndUpgrade(ver int64, upgrades *types1.StoreUpgrades) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadVersionAndUpgrade", ver, upgrades)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadVersionAndUpgrade indicates an expected call of LoadVersionAndUpgrade.
func (mr *MockCommitMultiStoreMockRecorder) LoadVersionAndUpgrade(ver, upgrades interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadVersionAndUpgrade", reflect.TypeOf((*MockCommitMultiStore)(nil).LoadVersionAndUpgrade), ver, upgrades)
}

// MountStoreWithDB mocks base method.
func (m *MockCommitMultiStore) MountStoreWithDB(key types1.StoreKey, typ types1.StoreType, db db.DB) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "MountStoreWithDB", key, typ, db)
}

// MountStoreWithDB indicates an expected call of MountStoreWithDB.
func (mr *MockCommitMultiStoreMockRecorder) MountStoreWithDB(key, typ, db interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MountStoreWithDB", reflect.TypeOf((*MockCommitMultiStore)(nil).MountStoreWithDB), key, typ, db)
}

// PopStateCache mocks base method.
func (m *MockCommitMultiStore) PopStateCache() []*types1.StoreKVPair {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PopStateCache")
	ret0, _ := ret[0].([]*types1.StoreKVPair)
	return ret0
}

// PopStateCache indicates an expected call of PopStateCache.
func (mr *MockCommitMultiStoreMockRecorder) PopStateCache() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PopStateCache", reflect.TypeOf((*MockCommitMultiStore)(nil).PopStateCache))
}

// PruneSnapshotHeight mocks base method.
func (m *MockCommitMultiStore) PruneSnapshotHeight(height int64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PruneSnapshotHeight", height)
}

// PruneSnapshotHeight indicates an expected call of PruneSnapshotHeight.
func (mr *MockCommitMultiStoreMockRecorder) PruneSnapshotHeight(height interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PruneSnapshotHeight", reflect.TypeOf((*MockCommitMultiStore)(nil).PruneSnapshotHeight), height)
}

// Restore mocks base method.
func (m *MockCommitMultiStore) Restore(height uint64, format uint32, protoReader io.Reader) (types0.SnapshotItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Restore", height, format, protoReader)
	ret0, _ := ret[0].(types0.SnapshotItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Restore indicates an expected call of Restore.
func (mr *MockCommitMultiStoreMockRecorder) Restore(height, format, protoReader interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Restore", reflect.TypeOf((*MockCommitMultiStore)(nil).Restore), height, format, protoReader)
}

// RollbackToVersion mocks base method.
func (m *MockCommitMultiStore) RollbackToVersion(version int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackToVersion", version)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackToVersion indicates an expected call of RollbackToVersion.
func (mr *MockCommitMultiStoreMockRecorder) RollbackToVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackToVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).RollbackToVersion), version)
}

// SetIAVLCacheSize mocks base method.
func (m *MockCommitMultiStore) SetIAVLCacheSize(size int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetIAVLCacheSize", size)
}

// SetIAVLCacheSize indicates an expected call of SetIAVLCacheSize.
func (mr *MockCommitMultiStoreMockRecorder) SetIAVLCacheSize(size interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetIAVLCacheSize", reflect.TypeOf((*MockCommitMultiStore)(nil).SetIAVLCacheSize), size)
}

// SetIAVLDisableFastNode mocks base method.
func (m *MockCommitMultiStore) SetIAVLDisableFastNode(disable bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetIAVLDisableFastNode", disable)
}

// SetIAVLDisableFastNode indicates an expected call of SetIAVLDisableFastNode.
func (mr *MockCommitMultiStoreMockRecorder) SetIAVLDisableFastNode(disable interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetIAVLDisableFastNode", reflect.TypeOf((*MockCommitMultiStore)(nil).SetIAVLDisableFastNode), disable)
}

// SetInitialVersion mocks base method.
func (m *MockCommitMultiStore) SetInitialVersion(version int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetInitialVersion", version)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetInitialVersion indicates an expected call of SetInitialVersion.
func (mr *MockCommitMultiStoreMockRecorder) SetInitialVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetInitialVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).SetInitialVersion), version)
}

// SetInterBlockCache mocks base method.
func (m *MockCommitMultiStore) SetInterBlockCache(arg0 types1.MultiStorePersistentCache) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetInterBlockCache", arg0)
}

// SetInterBlockCache indicates an expected call of SetInterBlockCache.
func (mr *MockCommitMultiStoreMockRecorder) SetInterBlockCache(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetInterBlockCache", reflect.TypeOf((*MockCommitMultiStore)(nil).SetInterBlockCache), arg0)
}

// SetKVStores mocks base method.
func (m *MockCommitMultiStore) SetKVStores(handler func(types1.StoreKey, types1.KVStore) types1.CacheWrap) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetKVStores", handler)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetKVStores indicates an expected call of SetKVStores.
func (mr *MockCommitMultiStoreMockRecorder) SetKVStores(handler interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetKVStores", reflect.TypeOf((*MockCommitMultiStore)(nil).SetKVStores), handler)
}

// SetMetrics mocks base method.
func (m *MockCommitMultiStore) SetMetrics(metrics metrics.StoreMetrics) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetMetrics", metrics)
}

// SetMetrics indicates an expected call of SetMetrics.
func (mr *MockCommitMultiStoreMockRecorder) SetMetrics(metrics interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMetrics", reflect.TypeOf((*MockCommitMultiStore)(nil).SetMetrics), metrics)
}

// SetPruning mocks base method.
func (m *MockCommitMultiStore) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning.
func (mr *MockCommitMultiStoreMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitMultiStore)(nil).SetPruning), arg0)
}

// SetSnapshotInterval mocks base method.
func (m *MockCommitMultiStore) SetSnapshotInterval(snapshotInterval uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetSnapshotInterval", snapshotInterval)
}

// SetSnapshotInterval indicates an expected call of SetSnapshotInterval.
func (mr *MockCommitMultiStoreMockRecorder) SetSnapshotInterval(snapshotInterval interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSnapshotInterval", reflect.TypeOf((*MockCommitMultiStore)(nil).SetSnapshotInterval), snapshotInterval)
}

// SetTracer mocks base method.
func (m *MockCommitMultiStore) SetTracer(w io0.Writer) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracer", w)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetTracer indicates an expected call of SetTracer.
func (mr *MockCommitMultiStoreMockRecorder) SetTracer(w interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracer", reflect.TypeOf((*MockCommitMultiStore)(nil).SetTracer), w)
}

// SetTracingContext mocks base method.
func (m *MockCommitMultiStore) SetTracingContext(arg0 types1.TraceContext) types1.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracingContext", arg0)
	ret0, _ := ret[0].(types1.MultiStore)
	return ret0
}

// SetTracingContext indicates an expected call of SetTracingContext.
func (mr *MockCommitMultiStoreMockRecorder) SetTracingContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracingContext", reflect.TypeOf((*MockCommitMultiStore)(nil).SetTracingContext), arg0)
}

// Snapshot mocks base method.
func (m *MockCommitMultiStore) Snapshot(height uint64, protoWriter io.Writer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot", height, protoWriter)
	ret0, _ := ret[0].(error)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockCommitMultiStoreMockRecorder) Snapshot(height, protoWriter interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockCommitMultiStore)(nil).Snapshot), height, protoWriter)
}

// StoreKeys mocks base method.
func (m *MockCommitMultiStore) StoreKeys() []types1.StoreKey {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreKeys")
	ret0, _ := ret[0].([]types1.StoreKey)
	return ret0
}

// StoreKeys indicates an expected call of StoreKeys.
func (mr *MockCommitMultiStoreMockRecorder) StoreKeys() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreKeys", reflect.TypeOf((*MockCommitMultiStore)(nil).StoreKeys))
}

// TracingEnabled mocks base method.
func (m *MockCommitMultiStore) TracingEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracingEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// TracingEnabled indicates an expected call of TracingEnabled.
func (mr *MockCommitMultiStoreMockRecorder) TracingEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracingEnabled", reflect.TypeOf((*MockCommitMultiStore)(nil).TracingEnabled))
}

// WorkingHash mocks base method.
func (m *MockCommitMultiStore) WorkingHash() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorkingHash")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// WorkingHash indicates an expected call of WorkingHash.
func (mr *MockCommitMultiStoreMockRecorder) WorkingHash() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorkingHash", reflect.TypeOf((*MockCommitMultiStore)(nil).WorkingHash))
}

// MockBasicKVStore is a mock of BasicKVStore interface.
type MockBasicKVStore struct {
	ctrl     *gomock.Controller
	recorder *MockBasicKVStoreMockRecorder
}

// MockBasicKVStoreMockRecorder is the mock recorder for MockBasicKVStore.
type MockBasicKVStoreMockRecorder struct {
	mock *MockBasicKVStore
}

// NewMockBasicKVStore creates a new mock instance.
func NewMockBasicKVStore(ctrl *gomock.Controller) *MockBasicKVStore {
	mock := &MockBasicKVStore{ctrl: ctrl}
	mock.recorder = &MockBasicKVStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBasicKVStore) EXPECT() *MockBasicKVStoreMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockBasicKVStore) Delete(key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Delete", key)
}

// Delete indicates an expected call of Delete.
func (mr *MockBasicKVStoreMockRecorder) Delete(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockBasicKVStore)(nil).Delete), key)
}

// Get mocks base method.
func (m *MockBasicKVStore) Get(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockBasicKVStoreMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockBasicKVStore)(nil).Get), key)
}

// Has mocks base method.
func (m *MockBasicKVStore) Has(key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockBasicKVStoreMockRecorder) Has(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockBasicKVStore)(nil).Has), key)
}

// Set mocks base method.
func (m *MockBasicKVStore) Set(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", key, value)
}

// Set indicates an expected call of Set.
func (mr *MockBasicKVStoreMockRecorder) Set(key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockBasicKVStore)(nil).Set), key, value)
}

// MockKVStore is a mock of KVStore interface.
type MockKVStore struct {
	ctrl     *gomock.Controller
	recorder *MockKVStoreMockRecorder
}

// MockKVStoreMockRecorder is the mock recorder for MockKVStore.
type MockKVStoreMockRecorder struct {
	mock *MockKVStore
}

// NewMockKVStore creates a new mock instance.
func NewMockKVStore(ctrl *gomock.Controller) *MockKVStore {
	mock := &MockKVStore{ctrl: ctrl}
	mock.recorder = &MockKVStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKVStore) EXPECT() *MockKVStoreMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method.
func (m *MockKVStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockKVStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockKVStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockKVStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockKVStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockKVStore)(nil).CacheWrapWithTrace), w, tc)
}

// Delete mocks base method.
func (m *MockKVStore) Delete(key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Delete", key)
}

// Delete indicates an expected call of Delete.
func (mr *MockKVStoreMockRecorder) Delete(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockKVStore)(nil).Delete), key)
}

// Get mocks base method.
func (m *MockKVStore) Get(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockKVStoreMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockKVStore)(nil).Get), key)
}

// GetStoreType mocks base method.
func (m *MockKVStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockKVStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockKVStore)(nil).GetStoreType))
}

// Has mocks base method.
func (m *MockKVStore) Has(key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockKVStoreMockRecorder) Has(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockKVStore)(nil).Has), key)
}

// Iterator mocks base method.
func (m *MockKVStore) Iterator(start, end []byte) types1.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterator", start, end)
	ret0, _ := ret[0].(types1.Iterator)
	return ret0
}

// Iterator indicates an expected call of Iterator.
func (mr *MockKVStoreMockRecorder) Iterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterator", reflect.TypeOf((*MockKVStore)(nil).Iterator), start, end)
}

// ReverseIterator mocks base method.
func (m *MockKVStore) ReverseIterator(start, end []byte) types1.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReverseIterator", start, end)
	ret0, _ := ret[0].(types1.Iterator)
	return ret0
}

// ReverseIterator indicates an expected call of ReverseIterator.
func (mr *MockKVStoreMockRecorder) ReverseIterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReverseIterator", reflect.TypeOf((*MockKVStore)(nil).ReverseIterator), start, end)
}

// Set mocks base method.
func (m *MockKVStore) Set(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", key, value)
}

// Set indicates an expected call of Set.
func (mr *MockKVStoreMockRecorder) Set(key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockKVStore)(nil).Set), key, value)
}

// MockCacheKVStore is a mock of CacheKVStore interface.
type MockCacheKVStore struct {
	ctrl     *gomock.Controller
	recorder *MockCacheKVStoreMockRecorder
}

// MockCacheKVStoreMockRecorder is the mock recorder for MockCacheKVStore.
type MockCacheKVStoreMockRecorder struct {
	mock *MockCacheKVStore
}

// NewMockCacheKVStore creates a new mock instance.
func NewMockCacheKVStore(ctrl *gomock.Controller) *MockCacheKVStore {
	mock := &MockCacheKVStore{ctrl: ctrl}
	mock.recorder = &MockCacheKVStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheKVStore) EXPECT() *MockCacheKVStoreMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method.
func (m *MockCacheKVStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockCacheKVStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheKVStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockCacheKVStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockCacheKVStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheKVStore)(nil).CacheWrapWithTrace), w, tc)
}

// Delete mocks base method.
func (m *MockCacheKVStore) Delete(key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Delete", key)
}

// Delete indicates an expected call of Delete.
func (mr *MockCacheKVStoreMockRecorder) Delete(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCacheKVStore)(nil).Delete), key)
}

// Get mocks base method.
func (m *MockCacheKVStore) Get(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockCacheKVStoreMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCacheKVStore)(nil).Get), key)
}

// GetStoreType mocks base method.
func (m *MockCacheKVStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockCacheKVStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCacheKVStore)(nil).GetStoreType))
}

// Has mocks base method.
func (m *MockCacheKVStore) Has(key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockCacheKVStoreMockRecorder) Has(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockCacheKVStore)(nil).Has), key)
}

// Iterator mocks base method.
func (m *MockCacheKVStore) Iterator(start, end []byte) types1.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterator", start, end)
	ret0, _ := ret[0].(types1.Iterator)
	return ret0
}

// Iterator indicates an expected call of Iterator.
func (mr *MockCacheKVStoreMockRecorder) Iterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterator", reflect.TypeOf((*MockCacheKVStore)(nil).Iterator), start, end)
}

// ReverseIterator mocks base method.
func (m *MockCacheKVStore) ReverseIterator(start, end []byte) types1.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReverseIterator", start, end)
	ret0, _ := ret[0].(types1.Iterator)
	return ret0
}

// ReverseIterator indicates an expected call of ReverseIterator.
func (mr *MockCacheKVStoreMockRecorder) ReverseIterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReverseIterator", reflect.TypeOf((*MockCacheKVStore)(nil).ReverseIterator), start, end)
}

// Set mocks base method.
func (m *MockCacheKVStore) Set(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", key, value)
}

// Set indicates an expected call of Set.
func (mr *MockCacheKVStoreMockRecorder) Set(key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCacheKVStore)(nil).Set), key, value)
}

// Write mocks base method.
func (m *MockCacheKVStore) Write() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Write")
}

// Write indicates an expected call of Write.
func (mr *MockCacheKVStoreMockRecorder) Write() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheKVStore)(nil).Write))
}

// MockCommitKVStore is a mock of CommitKVStore interface.
type MockCommitKVStore struct {
	ctrl     *gomock.Controller
	recorder *MockCommitKVStoreMockRecorder
}

// MockCommitKVStoreMockRecorder is the mock recorder for MockCommitKVStore.
type MockCommitKVStoreMockRecorder struct {
	mock *MockCommitKVStore
}

// NewMockCommitKVStore creates a new mock instance.
func NewMockCommitKVStore(ctrl *gomock.Controller) *MockCommitKVStore {
	mock := &MockCommitKVStore{ctrl: ctrl}
	mock.recorder = &MockCommitKVStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommitKVStore) EXPECT() *MockCommitKVStoreMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method.
func (m *MockCommitKVStore) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockCommitKVStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCommitKVStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockCommitKVStore) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockCommitKVStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCommitKVStore)(nil).CacheWrapWithTrace), w, tc)
}

// Commit mocks base method.
func (m *MockCommitKVStore) Commit() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockCommitKVStoreMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitKVStore)(nil).Commit))
}

// Delete mocks base method.
func (m *MockCommitKVStore) Delete(key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Delete", key)
}

// Delete indicates an expected call of Delete.
func (mr *MockCommitKVStoreMockRecorder) Delete(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCommitKVStore)(nil).Delete), key)
}

// Get mocks base method.
func (m *MockCommitKVStore) Get(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockCommitKVStoreMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCommitKVStore)(nil).Get), key)
}

// GetPruning mocks base method.
func (m *MockCommitKVStore) GetPruning() types.PruningOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPruning")
	ret0, _ := ret[0].(types.PruningOptions)
	return ret0
}

// GetPruning indicates an expected call of GetPruning.
func (mr *MockCommitKVStoreMockRecorder) GetPruning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPruning", reflect.TypeOf((*MockCommitKVStore)(nil).GetPruning))
}

// GetStoreType mocks base method.
func (m *MockCommitKVStore) GetStoreType() types1.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types1.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType.
func (mr *MockCommitKVStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCommitKVStore)(nil).GetStoreType))
}

// Has mocks base method.
func (m *MockCommitKVStore) Has(key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockCommitKVStoreMockRecorder) Has(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockCommitKVStore)(nil).Has), key)
}

// Iterator mocks base method.
func (m *MockCommitKVStore) Iterator(start, end []byte) types1.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterator", start, end)
	ret0, _ := ret[0].(types1.Iterator)
	return ret0
}

// Iterator indicates an expected call of Iterator.
func (mr *MockCommitKVStoreMockRecorder) Iterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterator", reflect.TypeOf((*MockCommitKVStore)(nil).Iterator), start, end)
}

// LastCommitID mocks base method.
func (m *MockCommitKVStore) LastCommitID() types1.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types1.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID.
func (mr *MockCommitKVStoreMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitKVStore)(nil).LastCommitID))
}

// ReverseIterator mocks base method.
func (m *MockCommitKVStore) ReverseIterator(start, end []byte) types1.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReverseIterator", start, end)
	ret0, _ := ret[0].(types1.Iterator)
	return ret0
}

// ReverseIterator indicates an expected call of ReverseIterator.
func (mr *MockCommitKVStoreMockRecorder) ReverseIterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReverseIterator", reflect.TypeOf((*MockCommitKVStore)(nil).ReverseIterator), start, end)
}

// Set mocks base method.
func (m *MockCommitKVStore) Set(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", key, value)
}

// Set indicates an expected call of Set.
func (mr *MockCommitKVStoreMockRecorder) Set(key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCommitKVStore)(nil).Set), key, value)
}

// SetPruning mocks base method.
func (m *MockCommitKVStore) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning.
func (mr *MockCommitKVStoreMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitKVStore)(nil).SetPruning), arg0)
}

// WorkingHash mocks base method.
func (m *MockCommitKVStore) WorkingHash() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorkingHash")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// WorkingHash indicates an expected call of WorkingHash.
func (mr *MockCommitKVStoreMockRecorder) WorkingHash() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorkingHash", reflect.TypeOf((*MockCommitKVStore)(nil).WorkingHash))
}

// MockCacheWrap is a mock of CacheWrap interface.
type MockCacheWrap struct {
	ctrl     *gomock.Controller
	recorder *MockCacheWrapMockRecorder
}

// MockCacheWrapMockRecorder is the mock recorder for MockCacheWrap.
type MockCacheWrapMockRecorder struct {
	mock *MockCacheWrap
}

// NewMockCacheWrap creates a new mock instance.
func NewMockCacheWrap(ctrl *gomock.Controller) *MockCacheWrap {
	mock := &MockCacheWrap{ctrl: ctrl}
	mock.recorder = &MockCacheWrapMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheWrap) EXPECT() *MockCacheWrapMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method.
func (m *MockCacheWrap) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockCacheWrapMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheWrap)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockCacheWrap) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockCacheWrapMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheWrap)(nil).CacheWrapWithTrace), w, tc)
}

// Write mocks base method.
func (m *MockCacheWrap) Write() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Write")
}

// Write indicates an expected call of Write.
func (mr *MockCacheWrapMockRecorder) Write() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheWrap)(nil).Write))
}

// MockCacheWrapper is a mock of CacheWrapper interface.
type MockCacheWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockCacheWrapperMockRecorder
}

// MockCacheWrapperMockRecorder is the mock recorder for MockCacheWrapper.
type MockCacheWrapperMockRecorder struct {
	mock *MockCacheWrapper
}

// NewMockCacheWrapper creates a new mock instance.
func NewMockCacheWrapper(ctrl *gomock.Controller) *MockCacheWrapper {
	mock := &MockCacheWrapper{ctrl: ctrl}
	mock.recorder = &MockCacheWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheWrapper) EXPECT() *MockCacheWrapperMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method.
func (m *MockCacheWrapper) CacheWrap() types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap.
func (mr *MockCacheWrapperMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheWrapper)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method.
func (m *MockCacheWrapper) CacheWrapWithTrace(w io0.Writer, tc types1.TraceContext) types1.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types1.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace.
func (mr *MockCacheWrapperMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheWrapper)(nil).CacheWrapWithTrace), w, tc)
}

// MockStoreKey is a mock of StoreKey interface.
type MockStoreKey struct {
	ctrl     *gomock.Controller
	recorder *MockStoreKeyMockRecorder
}

// MockStoreKeyMockRecorder is the mock recorder for MockStoreKey.
type MockStoreKeyMockRecorder struct {
	mock *MockStoreKey
}

// NewMockStoreKey creates a new mock instance.
func NewMockStoreKey(ctrl *gomock.Controller) *MockStoreKey {
	mock := &MockStoreKey{ctrl: ctrl}
	mock.recorder = &MockStoreKeyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStoreKey) EXPECT() *MockStoreKeyMockRecorder {
	return m.recorder
}

// Name mocks base method.
func (m *MockStoreKey) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockStoreKeyMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockStoreKey)(nil).Name))
}

// String mocks base method.
func (m *MockStoreKey) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockStoreKeyMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockStoreKey)(nil).String))
}

// MockMultiStorePersistentCache is a mock of MultiStorePersistentCache interface.
type MockMultiStorePersistentCache struct {
	ctrl     *gomock.Controller
	recorder *MockMultiStorePersistentCacheMockRecorder
}

// MockMultiStorePersistentCacheMockRecorder is the mock recorder for MockMultiStorePersistentCache.
type MockMultiStorePersistentCacheMockRecorder struct {
	mock *MockMultiStorePersistentCache
}

// NewMockMultiStorePersistentCache creates a new mock instance.
func NewMockMultiStorePersistentCache(ctrl *gomock.Controller) *MockMultiStorePersistentCache {
	mock := &MockMultiStorePersistentCache{ctrl: ctrl}
	mock.recorder = &MockMultiStorePersistentCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMultiStorePersistentCache) EXPECT() *MockMultiStorePersistentCacheMockRecorder {
	return m.recorder
}

// GetStoreCache mocks base method.
func (m *MockMultiStorePersistentCache) GetStoreCache(key types1.StoreKey, store types1.CommitKVStore) types1.CommitKVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreCache", key, store)
	ret0, _ := ret[0].(types1.CommitKVStore)
	return ret0
}

// GetStoreCache indicates an expected call of GetStoreCache.
func (mr *MockMultiStorePersistentCacheMockRecorder) GetStoreCache(key, store interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreCache", reflect.TypeOf((*MockMultiStorePersistentCache)(nil).GetStoreCache), key, store)
}

// Reset mocks base method.
func (m *MockMultiStorePersistentCache) Reset() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Reset")
}

// Reset indicates an expected call of Reset.
func (mr *MockMultiStorePersistentCacheMockRecorder) Reset() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockMultiStorePersistentCache)(nil).Reset))
}

// Unwrap mocks base method.
func (m *MockMultiStorePersistentCache) Unwrap(key types1.StoreKey) types1.CommitKVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unwrap", key)
	ret0, _ := ret[0].(types1.CommitKVStore)
	return ret0
}

// Unwrap indicates an expected call of Unwrap.
func (mr *MockMultiStorePersistentCacheMockRecorder) Unwrap(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unwrap", reflect.TypeOf((*MockMultiStorePersistentCache)(nil).Unwrap), key)
}

// MockStoreWithInitialVersion is a mock of StoreWithInitialVersion interface.
type MockStoreWithInitialVersion struct {
	ctrl     *gomock.Controller
	recorder *MockStoreWithInitialVersionMockRecorder
}

// MockStoreWithInitialVersionMockRecorder is the mock recorder for MockStoreWithInitialVersion.
type MockStoreWithInitialVersionMockRecorder struct {
	mock *MockStoreWithInitialVersion
}

// NewMockStoreWithInitialVersion creates a new mock instance.
func NewMockStoreWithInitialVersion(ctrl *gomock.Controller) *MockStoreWithInitialVersion {
	mock := &MockStoreWithInitialVersion{ctrl: ctrl}
	mock.recorder = &MockStoreWithInitialVersionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStoreWithInitialVersion) EXPECT() *MockStoreWithInitialVersionMockRecorder {
	return m.recorder
}

// SetInitialVersion mocks base method.
func (m *MockStoreWithInitialVersion) SetInitialVersion(version int64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetInitialVersion", version)
}

// SetInitialVersion indicates an expected call of SetInitialVersion.
func (mr *MockStoreWithInitialVersionMockRecorder) SetInitialVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetInitialVersion", reflect.TypeOf((*MockStoreWithInitialVersion)(nil).SetInitialVersion), version)
}
